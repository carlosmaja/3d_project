# -*- coding: utf-8 -*-
"""Clusters_&_Watershed_NODULAR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rFdtrC8Fl2zrGobyJymQW8gyOLrdbUjY

## import all libraries & Load Images
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import cv2
import numpy as np
from PIL import Image
import glob
# %pip install patchify
from patchify import patchify, unpatchify

from skimage import img_as_ubyte
from matplotlib import pyplot as plt
from PIL import Image
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler, StandardScaler
#import tifffile as tfl
#import matplotlib.image as mpimg

# %pip install keras_unet_collection
from keras_unet_collection import models, losses


from google.colab import drive
drive.mount('/content/drive')

from skimage import io, util
# Leer todas las imágenes JPG en un directorio específico
imagenes = []
files=[]
for i in range(1,10):
  file=(f'/content/drive/MyDrive/Nodular HV3 C y C/modulos_HV3_200x_0{i}.tif')
  #print(file)
  files.append(file)

for i in range(10,121):
  file=(f'/content/drive/MyDrive/Nodular HV3 C y C/modulos_HV3_200x_{i}.tif')
  #print(file)
  files.append(file)

for each in files:
  img = cv2.imread(each)  #Try houses.jpg or neurons.jpg
  img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
  #img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  arr = np.array(img, dtype=np.uint8) # Convertir la imagen a un arreglo de NumPy
  imagenes.append(arr)

mask = io.imread("/content/drive/MyDrive/Colab Notebooks/Nodular/hierro_alineado1.tiff")
#mask= np.array(mask, dtype=np.uint8)

"""# CLUSTERS"""

from sklearn.cluster import KMeans
imagenes_reshaped = []
for img in imagenes:
  x=img.reshape(-1,3)
  imagenes_reshaped.append(x)
print(imagenes_reshaped[0].shape[0])

imagen1=imagenes_reshaped[0]
kmeans=KMeans(n_clusters=3, n_init=10)
#kmeans.fit(imagenes_reshaped[0])

#segmented_img= kmeans.cluster_centers_[kmeans.labels_]
#segmented_img_=segmented_img.reshape(imagenes[0].shape)
#print(kmeans.labels_)

import matplotlib.pyplot as plt
import seaborn as sns
from mpl_toolkits.mplot3d import Axes3D


# Splitting the RGB from image
xx=[]
yy=[]
red=[]
green=[]
blue=[]
rojo = imagenes[0][:,:,0]
verde = imagenes[0][:,:,1]
azul = imagenes[0][:,:,2]

for x in range (rojo.shape[0]):
  for y in range (rojo.shape[1]):
    xx.append(x)
    yy. append (y)
    red.append(rojo[x][y])
    green.append(verde[x][y])
    blue.append(azul[x][y])

##plot
fig = plt.figure(figsize=(9, 9))
ax = fig.add_subplot(111, projection='3d')

scatter = ax.scatter(red, yy, xx, marker='o', c=red, cmap='Reds_r')
scatter = ax.scatter(green, yy, xx, marker='*', c=green, cmap='Greens_r')
scatter = ax.scatter(blue, yy, xx, marker='+', c=blue, cmap='Blues_r')

# Add labels and title
ax.set_zlabel('Pixel X (px)')
ax.set_ylabel('Pixel Y (px)')
ax.set_xlabel('RGB values (0-255)')
ax.set_title('3D Scatter Plot SEM IMAGE')


plt.show()

##plot
fig = plt.figure(figsize=(9, 9))
ax = fig.add_subplot(111, projection='3d')

scatter = ax.scatter(red, green, blue, marker='o', c=red, cmap='inferno')
#scatter = ax.scatter(green, yy, xx, marker='*', c=green, cmap='Greens_r')
#scatter = ax.scatter(blue, yy, xx, marker='+', c=blue, cmap='Blues_r')

# Add labels and title
ax.set_xlabel('RED (px)')
ax.set_ylabel('GREEN (px)')
ax.set_zlabel('BLUE (px)')
ax.set_title('3D Scatter Plot RGB')


plt.show()

def change_white_black(image_array):
    # Encontrar los píxeles blancos y cambiarlos a negros
    white_pixels = (image_array == 255)
    black_pixels = (image_array == 0)
    image_array[white_pixels] = 0
    image_array[black_pixels] = 255

def change_0_1 (image_array):
    # Encontrar los píxeles blancos y cambiarlos a negros
    white_pixels = (image_array == 255)
    black_pixels = (image_array == 0)
    image_array[white_pixels] = 1
    image_array[black_pixels] = 0


import tensorflow as tf
from tensorflow.keras.metrics import MeanIoU
from skimage.metrics import mean_squared_error

kmeans.fit(imagenes_reshaped[0])
  segmented_img= kmeans.cluster_centers_[kmeans.labels_]
  print(kmeans.cluster_centers_)
  print("=======================================================")
  print(segmented_img)
  #segmented_img_=segmented_img.reshape(imagenes[n].shape)

n=0
clustered_images=[]

error={}#dictionary error[number of image]=[mean squared error value, IOU value, otras metricas que deberia ponerle]

#flood fill per cluster---weak
#pixel counting per cluster--nice
#color ---too weak
#bounding box de cada cluster


#imagen binary*----- IoU, median filter(if it doesnt work morphology)---eliminar los puntos chiquitos(salt and pepper noise)

for each in imagenes_reshaped:
  kmeans.fit(each)
  segmented_img= kmeans.cluster_centers_[kmeans.labels_]
  segmented_img_=segmented_img.reshape(imagenes[n].shape)
  img=np.array(segmented_img_, dtype=np.uint8)
  clustered_images.append(img)
  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  min= np.min(img)
  #_, img = cv2.threshold(img, 130, 255, cv2.THRESH_BINARY)
  img = np.where((img > min), 255, 0)
  #contornos, jerarquia = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  mascara=mask[n]


  plt.figure(figsize=(12, 12))
  plt.subplot(131)
  plt.title(f'Original {n}')
  plt.imshow(imagenes[n], cmap='gray')
  plt.subplot(132)
  plt.imshow (img, cmap="gray")
  plt.title('cluster')
  plt.subplot(133)
  plt.imshow (mascara, cmap="gray")
  plt.title(' G Truth Mask')
  plt.show()

  #change_white_black(mascara)
  print(mascara[0][0])
  print(img[0][0])

##-----IMPORTANTE----Aqui cambio el formato, si quieres recuperar debes correr
#                     todo el codigo desde cargar las imagenes u optimizarlo


  change_0_1 (img)
  change_0_1 (mascara)
  mse_value = np.mean((mascara - img ) ** 2)
  # Definir la métrica MeanIoU
  #mean_iou = MeanIoU(num_classes=2)
  # Actualizar la métrica con los datos de ejemplo
  #mean_iou.update_state(img, mascara)
  # Calcular el Mean IoU
  #Iou_VALUE = mean_iou.result().numpy()




  #error.append(mse_value,Iou_VALUE)
# Print the MSE
  print("Mean Squared Error (MSE):", mse_value)
  error[n] = [mse_value]
  n+=1

# Splitting the RGB from image
xx=[]
yy=[]
red=[]
green=[]
blue=[]
rojo = clustered_images[0][:,:,0]
verde = clustered_images[0][:,:,1]
azul = clustered_images[0][:,:,2]

for x in range (rojo.shape[0]):
  for y in range (rojo.shape[1]):
    xx.append(x)
    yy. append (y)
    red.append(rojo[x][y])
    green.append(verde[x][y])
    blue.append(azul[x][y])

##plot
fig = plt.figure(figsize=(9, 9))
ax = fig.add_subplot(111, projection='3d')

scatter = ax.scatter(red, yy, xx, marker='o', c=red, cmap='Reds_r')
scatter = ax.scatter(green, yy, xx, marker='*', c=green, cmap='Greens_r')
scatter = ax.scatter(blue, yy, xx, marker='+', c=blue, cmap='Blues_r')

# Add labels and title
ax.set_xlabel('Pixel X (mm)')
ax.set_ylabel('Pixel Y (mm)')
ax.set_zlabel('Pixel value (mm)')
ax.set_title('3D Scatter Plot SEM IMAGE')


plt.show()

num_imagen=70
img=clustered_images[num_imagen]
plt.figure(figsize=(12, 12))
plt.subplot(121)
plt.title(f'Original '+str(num_imagen))
plt.imshow(imagenes[num_imagen], cmap='gray')
plt.subplot(122)
plt.imshow (img, cmap="gray")
plt.title('cluster')
plt.show()

# Crear una lista de listas que contenga los valores importantes para cada clave
value1_array = [value[0] for value in error.values()]
#value2_array = [value[1] for value in error.values()]



plt.subplots(1, 2, figsize=(10, 5))
# Crear dos subplots
plt.subplot(1, 2, 1)
plt.hist(value1_array, bins=10, color='skyblue', edgecolor='black')
plt.title('Distribución del Mean Squared Error (MSE)')
plt.xlabel('Valores')
plt.ylabel('Mean Squared Error (MSE)')
plt.grid(True)
"""
plt.subplot(1, 2, 2)
plt.hist(value2_array, bins=10, color='skyblue', edgecolor='black')
plt.title('Distribución del IoU (Jaccard)')
plt.xlabel('Valores')
plt.ylabel('IoU (Jaccard)')
plt.grid(True)
"""
# Ajustar el espaciado entre subplots
plt.tight_layout()

# Mostrar la figura con los subplots
plt.show()

plt.subplots(1, 2, figsize=(10, 5))
# Crear dos subplots
plt.subplot(1, 2, 1)
plt.boxplot(value1_array)
plt.title('Distribución del Mean Squared Error (MSE)')
plt.xlabel('Distancia entre el valor verdadero y la prediccion')
plt.ylabel('Mean Squared Error (MSE)')
plt.grid(True)

plt.subplot(1, 2, 2)
plt.boxplot(value2_array)
plt.title('Distribución del IoU (Jaccard)')
plt.xlabel('IoU=0=superposición incorrecta   IoU=1=superposición perfecta')
plt.ylabel('IoU')
plt.grid(True)

# Ajustar el espaciado entre subplots
plt.tight_layout()

# Mostrar la figura con los subplots
plt.show()

"""# Watershed"""

#taken from https://www.youtube.com/watch?v=AsTvGxuiqKs
"""
https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_watershed/py_watershed.html

It uses watershed segmentationfor better segmentation.
"""

from scipy import ndimage
from skimage import measure, color, io

pixels_to_um = 0.454 # 1 pixel = 454 nm (got this from the metadata of original image)

#Threshold image to binary using OTSU. ALl thresholded pixels will be set to 255
img = cv2.cvtColor(imagenes[0], cv2.COLOR_BGR2GRAY)
_, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)

# Morphological operations to remove small noise - opening
#To remove holes we can use closing
kernel = np.ones((3,3),np.uint8)
opening = cv2.morphologyEx(thresh,cv2.MORPH_OPEN, kernel, iterations = 2)

# let us start by identifying sure background area
sure_bg = cv2.dilate(opening,kernel,iterations=10)

# Finding sure foreground area using distance transform and thresholding
dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2,3)

plt.figure(figsize=(12, 12))
plt.subplot(221)
plt.title('Original')
plt.imshow(imagenes[0], cmap='gray')
plt.subplot(222)
plt.imshow (dist_transform)
plt.title('"Dist transform"')
plt.show()

#Let us threshold the dist transform by starting at 1/2 its max value.
print(dist_transform.max()) #gives about 21.9
ret2, sure_fg = cv2.threshold(dist_transform,0.01*dist_transform.max(),255,0)

# Unknown ambiguous region is nothing but bkground - foreground
sure_fg = np.uint8(sure_fg)
unknown = cv2.subtract(sure_bg, sure_fg)

ret3, markers = cv2.connectedComponents(sure_fg)

markers = markers+10

markers[unknown==255] = 0
#plt.imshow(markers, cmap='jet')

#Now we are ready for watershed filling.
#markers = cv2.watershed(imagenes[0],markers)

imagenes[0][markers == -1] = [0,255,255]

img2 = color.label2rgb(markers, bg_label=0)

plt.figure(figsize=(12, 12))
plt.subplot(221)
plt.title('Original')
plt.imshow(imagenes[0])
plt.subplot(222)
plt.imshow (markers)
plt.title('"markers')
plt.show()

#from skimage.segmentation import clear_border
#opening = clear_border(opening) #Remove edge touching grains
#Check the total regions found before and after applying this.

#Now we create a marker and label the regions inside.
# For sure regions, both foreground and background will be labeled with positive numbers.
# Unknown regions will be labeled 0.
#For markers let us use ConnectedComponents.


#One problem rightnow is that the entire background pixels is given value 0.
#This means watershed considers this region as unknown.
#So let us add 10 to all labels so that sure background is not 0, but 10


#The boundary region will be marked -1
#https://docs.opencv.org/3.3.1/d7/d1b/group__imgproc__misc.html#ga3267243e4d3f95165d55a618c65ac6e1

#Let us color boundaries in yellow.


#plt.imshow( imagenes[0])#'Overlay on original image',
plt.imshow(img2)#'Colored Grains',