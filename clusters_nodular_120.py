# -*- coding: utf-8 -*-
"""Copia de Clusters_NODULAR_120.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10AYSHhAdAdOaNg45yHE4l6fcaKQ3tv1X

## import all libraries & Load Images
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import cv2
import numpy as np
from PIL import Image
import glob
# %pip install patchify
from patchify import patchify, unpatchify

from skimage import img_as_ubyte
from matplotlib import pyplot as plt
from PIL import Image
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler, StandardScaler
#import tifffile as tfl
#import matplotlib.image as mpimg

# %pip install keras_unet_collection
from keras_unet_collection import models, losses

from google.colab import drive
drive.mount('/content/drive')

from skimage import io, util
# Leer todas las imágenes JPG en un directorio específico
imagenes = []
files=[]
for i in range(1,10):
  file=(f'/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_000{i-1}_modulos_HV3_200x_0{i}.jpg.jpg')
  #print(file)
  files.append(file)
files.append('/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_0009_modulos_HV3_200x_10.jpg.jpg')
for i in range(10,45):
  file=(f'/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_00{i}_modulos_HV3_200x_{i+1}.jpg.jpg')
  #print(file)
  files.append(file)
files.append('/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_0045_modulos_HV3_200x_45-2.jpg.jpg')
for i in range(46,96):
  file=(f'/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_00{i}_modulos_HV3_200x_{i}.jpg.jpg')
  #print(file)
  files.append(file)
files.append('/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_0096_modulos_HV3_200x_95-2.jpg.jpg')
for i in range(96,99):
  file=(f'/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_00{i+1}_modulos_HV3_200x_{i}.jpg.jpg')
  #print(file)
  files.append(file)
#files.append('/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_0099_modulos_HV3_200x_100.jpg.jpg')
for i in range(99,120):
  file=(f'/content/drive/MyDrive/Imagenes Alineadas PS/Imagenes_Alineadas_1/Imagenes_Alineadas_Cortadas_0{i+1}_modulos_HV3_200x_{i}.jpg.jpg')
  #print(file)
  files.append(file)


for each in files:
  img = cv2.imread(each)
  print(each)
  img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
  #img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  arr = np.array(img, dtype=np.uint8) # Convertir la imagen a un arreglo de NumPy
  imagenes.append(arr)

mask = io.imread("/content/drive/MyDrive/Colab Notebooks/Nodular/hierro_alineado.tiff")
#mask= np.array(mask, dtype=np.uint8)

"""# CLUSTERS"""

from sklearn.cluster import KMeans
imagenes_reshaped = []
for img in imagenes:
  x=img.reshape(-1,3)
  imagenes_reshaped.append(x)
print(imagenes_reshaped[0].shape[0])

imagen1=imagenes_reshaped[0]
kmeans=KMeans(n_clusters=3, n_init=10)

#kmeans.fit(imagenes_reshaped[0])

#segmented_img= kmeans.cluster_centers_[kmeans.labels_]
#segmented_img_=segmented_img.reshape(imagenes[0].shape)
#print(kmeans.labels_)

def change_white_black(image_array):
    # Encontrar los píxeles blancos y cambiarlos a negros
    white_pixels = (image_array == 255)
    black_pixels = (image_array == 0)
    image_array[white_pixels] = 0
    image_array[black_pixels] = 255

def change_0_1 (image_array):
    # Encontrar los píxeles blancos y cambiarlos a negros
    white_pixels = (image_array == 255)
    black_pixels = (image_array == 0)
    image_array[white_pixels] = 1
    image_array[black_pixels] = 0
def change_white_black(image_array):
    # Encontrar los píxeles blancos y cambiarlos a negros
    white_pixels = (image_array == 255)
    black_pixels = (image_array == 0)
    image_array[white_pixels] = 0
    image_array[black_pixels] = 255

def change_0_1 (image_array):
    # Encontrar los píxeles blancos y cambiarlos a negros
    white_pixels = (image_array == 255)
    black_pixels = (image_array == 0)
    image_array[white_pixels] = 1
    image_array[black_pixels] = 0

def pixel_counting (image_array, cluster_centers):
  dic={}
  n=-1
  for _ in cluster_centers:
    n+=1
    dic[n]=0
  # Iterate through each cluster
  for x in range (image_array.shape[0]):
    for y in range (image_array.shape[1]):
      pixel_value = image_array[x][y]
      #print(pixel_value)
      nn=-1
      for each in cluster_centers:
        nn+=1
      # Check if the pixel value matches any of the cluster centers
        if np.all(pixel_value == each):
          dic[nn] += 1
  return dic

def get_clave(diccionario, max_value):
  for clave, valor in diccionario.items():
      # Verifica si el valor coincide con el valor buscado
      if valor == max_value:
          # Si coincide, agrega la clave a la lista de claves coincidentes
          claves_coincidente=clave
  return claves_coincidente


import tensorflow as tf
from tensorflow.keras.metrics import MeanIoU
from skimage.metrics import mean_squared_error

kmeans.fit(imagenes_reshaped[0])
  segmented_img= kmeans.cluster_centers_[kmeans.labels_]
  print(kmeans.cluster_centers_)
  print("=======================================================")
  print(segmented_img)
  #segmented_img_=segmented_img.reshape(imagenes[n].shape)

n=0
clustered_images=[]

error={}#dictionary error[number of image]=[mean squared error value, IOU value, otras metricas que deberia ponerle]

#flood fill per cluster---weak
#pixel counting per cluster--nice
#color ---too weak
#bounding box de cada cluster


#imagen binary*----- IoU, median filter(if it doesnt work morphology)---eliminar los puntos chiquitos(salt and pepper noise)

for each in imagenes_reshaped:
  kmeans.fit(each)
  segmented_img= kmeans.cluster_centers_[kmeans.labels_]
  segmented_img_=segmented_img.reshape(imagenes[n].shape)
##---------Hasta aqui estaba yo feliz, luego llegó el duro golpe de realidad
  dict_pixel_counting=pixel_counting(segmented_img_, kmeans.cluster_centers_)
  valores_array = np.array(list(dict_pixel_counting.values()))
  ##SELECT background
  valor_maximo = max(valores_array)
  clave = get_clave(dict_pixel_counting,valor_maximo)
  color_buscado=kmeans.cluster_centers_[clave]
  nuevo_color = np.array([255, 255, 255])  # Blanco en formato RGB
  color_buscado = np.array(color_buscado)
# Encuentra todos los píxeles con el color buscado y cambia su color
  imagen_mascara = np.all(segmented_img_ == color_buscado)
  print(imagen_mascara.shape)
  print(color_buscado.shape)
  segmented_img[imagen_mascara] = nuevo_color
  img=np.array(segmented_img_, dtype=np.uint8)

  img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
  clustered_images.append(img)
  #max= np.max(img)
  #img = np.where((max > img), 0, 255)
  mascara=mask[n]

  kmeans.fit(each)
  segmented_img= kmeans.cluster_centers_[kmeans.labels_]
  segmented_img_=segmented_img.reshape(imagenes[n].shape)
  img=np.array(segmented_img_, dtype=np.uint8)
  clustered_images.append(img)
  """
  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  min= np.min(img)
  #_, img = cv2.threshold(img, 130, 255, cv2.THRESH_BINARY)
  img = np.where((img > min), 255, 0)
  #contornos, jerarquia = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
  """
  mascara= cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
  plt.figure(figsize=(12, 12))
  plt.subplot(131)
  plt.title(f'Original {n}')
  plt.imshow(imagenes[n], cmap='gray')
  plt.subplot(132)
  plt.imshow (img, cmap="gray")
  plt.title('cluster')
  plt.subplot(133)
  plt.imshow (mascara, cmap="gray")
  plt.title(' Gray cluster')
  plt.show()
  n+=1
  """


  #change_white_black(mascara)
  print(mascara[0][0])
  print(img[0][0])

##-----IMPORTANTE----Aqui cambio el formato, si quieres recuperar debes correr
#                     todo el codigo desde cargar las imagenes u optimizarlo


  change_0_1 (img)
  change_0_1 (mascara)
  #mse_value = np.mean((mascara - img ) ** 2)
  # Definir la métrica MeanIoU
  #mean_iou = MeanIoU(num_classes=2)
  # Actualizar la métrica con los datos de ejemplo
  #mean_iou.update_state(img, mascara)
  # Calcular el Mean IoU
  #Iou_VALUE = mean_iou.result().numpy()




  #error.append(mse_value,Iou_VALUE)
# Print the MSE
  #print("Mean Squared Error (MSE):", mse_value)
  #error[n] = [mse_value]
  """

n=0
final_images=[]
list=[7,10,13,14,16,18,19,
      21,23,24,25,26,27,28,29,30,
      31,32,33,34,35,36,37,38,39,40,41,42,43,
      58,
86,87,88,90,92,93,94,107,108,106,
      111,113,114,115,116,117,118,119,120]

for each in clustered_images:
  #img = cv2.cvtColor(each, cv2.COLOR_RGB2GRAY)
  img=each
  max= np.max(img)
  min= np.min(img)
  print(max)
  if n in list:
    img = np.where(( min<img), 255, 0)
  else:
    img = np.where((max > img), 0, 255)
  #_, img = cv2.threshold(img, 130, 255, cv2.THRESH_BINARY)
  #img = np.where((max > img), 255, 0)
  plt.figure(figsize=(4, 4))
  plt.subplot(121)
  plt.title(f'cluster {n}')
  plt.imshow(each, cmap='gray')
  plt.subplot(122)
  plt.imshow (img, cmap="gray")
  plt.title(f'cluster {n}')
  plt.show()
  final_images.append(img)
  n+=1

import os
import zipfile
from PIL import Image
import numpy as np

# Crear un directorio para guardar las imágenes
output_dir = '/content/final_images'
os.makedirs(output_dir, exist_ok=True)

# Guardar cada imagen en el directorio
for i, img_array in enumerate(final_images):
    img = Image.fromarray(img_array.astype(np.uint8))
    img_path = os.path.join(output_dir, f'img_{i+1}.tif')
    img.save(img_path)

# Crear un archivo ZIP con todas las imágenes en el directorio
zip_filename = '/content/final_images.zip'
with zipfile.ZipFile(zip_filename, 'w') as zipf:
    for root, dirs, files in os.walk(output_dir):
        for file in files:
            zipf.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), os.path.join(output_dir, '..')))

# Descargar el archivo ZIP (opcional)
from google.colab import files
files.download(zip_filename)

# Splitting the RGB from image
xx=[]
yy=[]
red=[]
green=[]
blue=[]
rojo = clustered_images[0][:,:,0]
verde = clustered_images[0][:,:,1]
azul = clustered_images[0][:,:,2]

for x in range (rojo.shape[0]):
  for y in range (rojo.shape[1]):
    xx.append(x)
    yy. append (y)
    red.append(rojo[x][y])
    green.append(verde[x][y])
    blue.append(azul[x][y])

##plot
fig = plt.figure(figsize=(9, 9))
ax = fig.add_subplot(111, projection='3d')

scatter = ax.scatter(red, yy, xx, marker='o', c=red, cmap='Reds_r')
scatter = ax.scatter(green, yy, xx, marker='*', c=green, cmap='Greens_r')
scatter = ax.scatter(blue, yy, xx, marker='+', c=blue, cmap='Blues_r')

# Add labels and title
ax.set_xlabel('Pixel X (mm)')
ax.set_ylabel('Pixel Y (mm)')
ax.set_zlabel('Pixel value (mm)')
ax.set_title('3D Scatter Plot SEM IMAGE')


plt.show()

num_imagen=70
img=clustered_images[num_imagen]
plt.figure(figsize=(12, 12))
plt.subplot(121)
plt.title(f'Original '+str(num_imagen))
plt.imshow(imagenes[num_imagen], cmap='gray')
plt.subplot(122)
plt.imshow (img, cmap="gray")
plt.title('cluster')
plt.show()

# Crear una lista de listas que contenga los valores importantes para cada clave
value1_array = [value[0] for value in error.values()]
#value2_array = [value[1] for value in error.values()]



plt.subplots(1, 2, figsize=(10, 5))
# Crear dos subplots
plt.subplot(1, 2, 1)
plt.hist(value1_array, bins=10, color='skyblue', edgecolor='black')
plt.title('Distribución del Mean Squared Error (MSE)')
plt.xlabel('Valores')
plt.ylabel('Mean Squared Error (MSE)')
plt.grid(True)
"""
plt.subplot(1, 2, 2)
plt.hist(value2_array, bins=10, color='skyblue', edgecolor='black')
plt.title('Distribución del IoU (Jaccard)')
plt.xlabel('Valores')
plt.ylabel('IoU (Jaccard)')
plt.grid(True)
"""
# Ajustar el espaciado entre subplots
plt.tight_layout()

# Mostrar la figura con los subplots
plt.show()

plt.subplots(1, 2, figsize=(10, 5))
# Crear dos subplots
plt.subplot(1, 2, 1)
plt.boxplot(value1_array)
plt.title('Distribución del Mean Squared Error (MSE)')
plt.xlabel('Distancia entre el valor verdadero y la prediccion')
plt.ylabel('Mean Squared Error (MSE)')
plt.grid(True)

plt.subplot(1, 2, 2)
plt.boxplot(value2_array)
plt.title('Distribución del IoU (Jaccard)')
plt.xlabel('IoU=0=superposición incorrecta   IoU=1=superposición perfecta')
plt.ylabel('IoU')
plt.grid(True)

# Ajustar el espaciado entre subplots
plt.tight_layout()

# Mostrar la figura con los subplots
plt.show()